2023.03.27

# __자동 메모리 관리 이해__<br><br>

###  유니티 공식 문서를 정리한 문서입니다.

 [유니티 공식 문서_자동 메모리 관리의 이해](https://docs.unity.cn/kr/2021.1/Manual/UnderstandingAutomaticMemoryManagement.html)

----

## 📑 __목차__

- [자동 메모리 관리](#📌-자동-메모리-관리)

- [값 타입, 레퍼런스 타입](#📌-값-타입과-레퍼런스-타입)

- [메모리 할당, 가비지 컬렉션](#📌-메모리-할당-가비지-컬렉션)

- [가비지 컬렉션](#📌-가비지-컬렉션)

    - [세대별 가비지 컬렉터 알고리즘](#📌-세대별-가비지-컬렉터-알고리즘)

    - [Unity 가비지 컬렉션](#📌-unity-gc)

- [최적화](#📌-최적화)

    - [잦은 gc호출이 일어나는 사례](#잦은-gc호출이-일어나는-사례)

    - [게임 플레이에 영향을 최소화 하는 방법](#게임-플레이에-영향을-최소화하는-방법)

    - [오브젝트 풀](#오브젝트-풀)

- [점진적 가비지 컬렉션](#📌-점진적-가비지-컬렉션)


<br><Br>

## 📌 __자동 메모리 관리__

오브젝트, 문자열, 배열을 생성하면 힙heap에 저장됩니다.

공간을 할당받은 객체가 더 이상 사용되지 않으면 차지하던 메모리를 회수하여 다른 항목을 저장하는데 사용할 수 있습니다.

이전에는 프로그래머가 코드로 명시적으로 메모리를 할당하고 해제해야 했습니다.

하지만 Unity Mono엔진같은 런타임 시스템이 __메모리를 자동으로 관리__ 해줍니다.

이것은 __코딩이 덜 필요__ 하며 __메모리 누수 현상을 줄여줍니다.__<Br><Br>

 ## 📌 __값 타입과 레퍼런스 타입__

__함수를 호출__ 하면 __파라미터__ 로 주어지는 값들이 지정된 __메모리 구역에 복사__ 됩니다.

이때 int, float, bool, unity struct(Color, Vector3```)와 같은 몇 바이트 용량의 값타입들은 쉽게 복사되지만,

배열, 문자열, 오브젝트 들은 이보다 더 큰 경우가 많습니다.<br><Br>

이렇게 용량이 큰 값들을 파라미터로 가진 함수를 호출할때마다 복사하기에는 비효율적입니다.

따라서 실제 스토리지는 힙에 할당하고 위치를 기억하기위한 포인터를 복사하여 전달합니다.<br><Br>

파라미터가 전달되는 동안 __사본이 직접 저장되는 타입__ 을 __값 타입__ 이라고 하며,

힙에 할당하고 그 후 __포인터를 통해 참조하는 타입__ 을 __레퍼런스 타입__ 이라고 합니다.<br><Br>

## 📌 __메모리 할당__

힙에 있는 __참조항목을 접근__ 하려면 해당 항목을 찾을 수 있도록 하는 __참조변수__ 가 필요합니다.

__참조변수가 재할당__ 되거나 __로컬 변수로 변하는 경우__ 기존의 할당되었던 메모리는 __참조가 사라지고__ 사용되지 않는 영역이 됩니다.

메모리 관리자는 이런 사용되지 않는 메모리 영역을 트래킹합니다.<br><Br>

## 📌 __가비지 컬렉션__

트래킹 과정에서 메모리 관리자는 현재 모든 __액티브 참조 변수를 검색__ 하고,

이 변수가 참조하는 블록을 __"살아있음live"라고 표시__ 합니다.

그리고 살아있는 블록 사이의 모든 공간을 비어 있다고 간주하고 다음 할당 요청에 사용합니다.

이렇게 __미사용 메모리를 파악하고 해제하는 프로세스__ 를 __가비지 컬렉션 GC__ 이라 합니다.<BR><bR>

## 📌 __세대별 가비지 컬렉터 알고리즘__

### __세대별 가비지 컬렉터__

게임 오브젝트를 동적 생성/삭제 하는것은 가비지 컬렉터의 활동 빈도를 높입니다.

가비지 컬렉터 실행의 비용은 공짜가 아니기 때문에 신중하게 관리되어야 합니다.

때문에 오래 참조되어 사용될 객체들을 모아놓고 세대를 나눠줌으로써 메모리를 효율적으로 관리할 수 있습니다.
<Br>

- __0세대__ : 아직 가비지 컬렉션이 수행되지 않은 객체들

- __1세대__ : 가비지 컬렉션이 1번 수행되고 살아남은 객체들

- __2세대__ : 가비지 컬렉션이 2번 수행되고 살아남은 객체들
<br><Br>



### __객체의 수명 예측은 어떻게?__


<img src="https://user-images.githubusercontent.com/80774412/227879438-988c52ce-874b-40b9-ac7b-e56237ac1e23.png"></img>

- __새로 힙에 할당된 객체들을 모두 0세대로 포함합니다.__

    - 0세대의 메모리가 임계치에 도달하면 0세대에 대해 가비지 컬렉션을 수행합니다.

    - 가비지 컬렉션 후 살아남은 객체들을 1세대로 옮겨집니다.<Br>

- __이후 또 다른 객체들이 할당되면 0세대로 포함합니다.__

    - 0세대가 또 임계치에 도달하면 가비지 컬렉션을 수행합니다.<Br>

- __1세대가 임계치에 도달하면 가비지 컬렉션을 수행합니다.__

    - 0, 1 세대 모두 가비지 컬렉션이 실행됩니다.

    - 0세대에서 살아남은 객체들은 1세대로, 1세대에서 살아남은 객체들은 2세대로 옮겨집니다.<Br>

- __2세대가 임계치에 도달하면 더 이상 다른 세대로 옮겨지지 않고 전체 가비지 컬렉션을 실행합니다.__


2세대 힙이 객체로 가득차게 되어(풀GC) 전체 힙에대한 가비지 컬렉션이 실행될 때 CLR이 해당 어플리케이션을 일시 중단하고 실행합니다.

어플리케이션이 차지하는 메모리 공간이 많을수록 중단 시간이 길어집니다.<BR><bR>

### __가비지 컬렉션 줄이는 방법__

1. 객체의 생성 및 할당을 너무 많이 하지 않습니다.

2. 대형 객체의 힙 할당은 메모리 공간 효율을 낮춥니다. 

3. 객체 간 참조관계를 줄입니다.

    참조관계가 많은 객체는 2세대 힙까지 살아남을 가능성이 큽니다.

    세대를 옮길 때 해당 객체의 모든 필드의 참조관계를 조사하고 참조 메모리 주소를 변경해야 하기 때문에 오버헤드가 발생합니다.

4. 루트(?) 목록을 줄입니다.

[참고 문서](https://luv-n-interest.tistory.com/922)
<br><Br>

## 📌 __Unity GC__

유니티는 [*stop-the-world](#stop-the-world) 방식의 __Boehm-Deners-Weiser 가비지 컬렉터__ 를 사용합니다.

가비지 컬렉터가 처리하는데 필요한 __메모리 양__ 과 __플랫폼__ 에 따라 지연되는 시간이 달라집니다.

게임같은 실시간 애플리케이션의 경우 가비지 컬렉션으로 인해 게임 실행을 중단하면 부드러운 플레이를 위한 일관된 프레임 속도를 지속할 수 없습니다.

__이런 중단 문제__ 는 프로파일러 프레임 시간 그래프에서 높게 치솟은 모양을 보인다고 해서 __GC스파이크__ 로도 불립니다.<BR><bR>

## 📌 __최적화__

가비지 컬렉션은 내부적으로는 상당한 CPU시간을 요구하므로,

피룡 이상의 잦은 실행으로 게임이 멈추는 현상을 유발하는 실수를 막아야 합니다.<BR><bR>


### __잦은 GC호출이 일어나는 사례__

- 문자열 접합 반복

    ```C#
    string line = "A";
    line += "BC";
    ```

    문자열을 변수에 새로 연결하는 경우 실제로는 변수의 이전 내용이 삭제되며, 

    기존 조각 끝에 새로운 부분이 더해진 형태의 새로운 문자열이 할당됩니다.

    => 대부분 Update와 같은 잦은 호출이 있는 곳에서의 반복적인 문자열 접합이 아니라면 정상 작동합니다.

- 배열을 반환하는 함수

    ```C#
    float[] Test(int num)
    {
        float[] floats = new float[num];

        for(int i = 0; i < num; i ++)
        {
            float[i] = i;
        }
        return floats;
    }
    ```
    배열은 크기가 크기 때문에 힙의 공간이 빠르게 소모되어 가비지 컬렉션의 실행 빈도가 높아집니다.

    => 배열이 참조타입으로 포인터로 전달된다는 점을 이용하면 됩니다.

    => 파라미터로 전달된 배열은 함수안에서 변경된 내용이 그대로 적용되어 사라지지 않습니다.
    <br><Br>

### __게임 플레이에 영향을 최소화하는 방법__

- __1. 작은힙과 빠르고 빈번한 가비지 컬렉션__

    오래 플레이 되는 게임에서 부드러운 프레임률을 유지하는데 적합합니다.

    프로파일러를 통해 실제 시간이 감소되는지 통계 확인이 필요합니다.

- __2. 큰힙과 느리지만 덜 빈번한 가비지 컬렉션__

    메모리 할당과 가비지 컬렉션이 자주 발생하지 않는 게임에 적합합니다.

    힙 용량이 최대한 큰게 좋기떄문에 시작할 때 일부 플레이스홀더를 미리 할당 받습니다.
<br><Br>

### __오브젝트 풀__

오브젝트를 생성/삭제 하는 것보다 재사용하여 가비지 생성을 줄일 수 있습니다.<br><Br>

## 📌 __점진적 가비지 컬렉션__

점진적 가비지 컬렉션은 유니티가 제공하는 기본 제공 방식입니다.

가비지 컬렉션 프로세스를 여러 프레임에 걸쳐 분산합니다.

한 번에 긴 시간동안 프로그램을 일시 정지하지 않고, 여러번에 걸쳐 훨씬 짧은 시간동안만 중단합니다.

전반적인 작업 속도가 향상되지는 않지만 __스파이크를 줄일 수 있습니다.__<br><Br>

__프레임이 끝나기 전 이용 가능 시간 GC에 쓰는 방법__
- Edit-ProjectSettings-Quality-Application.VSync 활성화
- Edit-ProjectSettings-Quality- Application.targetFrameRate 활성화





<BR><BR>
---- 

## 💡 __관련 지식__

### __stop-the-world__

가비지 컬렉터가 작업을 실행하기 위해 어플리케이션 실행을 멈추는 방식입니다. [원문](#unity-gc)





