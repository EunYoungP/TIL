# __Dynamic Programming 동적 계획법__ <br><br>


__사용조건__

1. __최적 부분 구조__ (Optimal Substructure)

    큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있어야 한다.

2. __중복되는 부분 문제__ (Overlapping Subproblem)

    동일한 작은 문제를 반복적으로 해결해야 한다.<br><br>


### __예시 피보나치 수열__ 

<img src="https://user-images.githubusercontent.com/80774412/202375608-8dba38b9-5c22-43c7-8add-8f4f646e3bff.png" title="피보나치수열 점화식"></img><br><br>

__단순 재귀 소스코드__

```java
public static int fibo(int x) 
{
    if (x == 1 || x == 2) {
        return 1;
    }
    return fibo(x - 1) + fibo(x - 2);
}

public static void main(String[] args) 
{
    System.out.println(fibo(4));
}
```
<br><br>

__피보나치 수열의 시간 복잡도__

* 빅오 표기법 : O(2^N)

<img src="https://user-images.githubusercontent.com/80774412/202376379-af87a5d1-f965-4db9-a844-e2d2d2926212.png"title="피보나치수열_시간복잡도분석"></img>

단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.

위와 같이 f(2) 가 여러번 호출되어 중복되는 부분 문제를 가지는것을 볼 수 있습니다.<br><br>

### __피보나치 수열의 효율적인 해법 : 다이나믹 프로그래밍__

__다이나믹 프로그래밍 해결법 두가지__ 

__1. 탑다운 Top-down(하향식)__

    * 가장 큰 문제를 방문 후 작은 문제를 호출하여 답을 찾는 방식입니다.

    * 주로 재귀 호출을 이용하여 구현합니다.

    * 점화식을 이해하기 쉽다는 장점이 있습니다.

__2. 바텀업 Bottom-up(상향식)__

    * 가장 작은 문제들 부터 답을 구해가며 전체 문제의 답을 찾는 방식입니다.
    
    * 주로 반복문을 이용해 구현합니다.

    * 재귀 호출하지 않기 때문에 시간과 메모리 사용량을 줄일 수 있습니다.

__메모이제이션 Memoization__

* 메모이제이션(탑다운) 방식은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.

* 한 번 계산한 결과를 메모리 공간에 미모하는 기법입니다.

    * 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.

    * 값을 기록해 놓는다는 점에서 __캐싱(Caching)__ 이라고도 합니다.

    * 다이나믹 프로그래밍에 국한된 개념은 아닙니다. 한번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을수도 있습니다.
<br><Br>

__피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드__

```java
public class Main {

    // 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
    public static long[] d = new long[100];

    // 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
    public static long fibo(int x) {
        // 종료 조건(1 혹은 2일 때 1을 반환)
        if (x == 1 || x == 2) {
            return 1;
        }
        // 이미 계산한 적 있는 문제라면 그대로 반환
        if (d[x] != 0) {
            return d[x];
        }
        // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x - 1) + fibo(x - 2);
        return d[x];
    }

    public static void main(String[] args) {
        System.out.println(fibo(50));
    }
}
```

__피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드__
```java
public class Main {
    // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
    public static long[] d = new long[100];

    public static void main(String[] args) {
        // 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
        d[1] = 1;
        d[2] = 1;
        int n = 50; // 50번째 피보나치 수를 계산

        // 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
        for (int i = 3; i <= n; i++) {
            d[i] = d[i - 1] + d[i - 2];
        }
        System.out.println(d[n]);
    }
}
```
<br><br>

__피보나치 수열: 메모이제이션 동작 분석__

<img src="https://user-images.githubusercontent.com/80774412/202392102-9c4cfe16-40d7-41b5-b404-b787d7cef1fe.png" title="fibo_memoization"></img>

메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N) 이다.<br><br>


__다이나믹 프로그래밍 VS 분할 정복__

* 분할정복 알고리즘

    문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘입니다.

다이나믹 프로그래밍과 분할 정복은 모두 __최적 부분 구조__ 를 가질 때 사용할 수 있습니다.

차이점은 __부분 문제의 중복__ 입니다.

    다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.

    분할정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.

분할정복의 대표적인 예시인 __퀵정렬__ 에서, 한 번 기준 원소가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않습니다.

즉 해당 기준원소를 다시 처리하는 부분 문제는 호출되지 않습니다.


__다이나믹 프로그래밍 문제 접근 방법__

1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악합니다.
    
    * 가장 먼저 __그리디__, __구현__, __완전 탐색__ 등의 아이디어로 문제를 해결할 수 있는지 검토합니다.

    * 다른 알고리즘으로의 풀이 방법이 떠오르지 않으면 DP(다이나믹 프로그래밍)을 고려해 봅니다.

2. 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드르 개선하는 방법을 사용할 수 있습니다.





------
__참고 자료__

[다이나믹 프로그래밍](https://freedeveloper.tistory.com/276)
[탑다운 vs 바텀업](https://semaph.tistory.com/16)