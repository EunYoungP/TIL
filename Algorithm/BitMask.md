2023.03.13

# __BitMast 비트마스크__

[비트 마스크 관련 문제](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

---- 

## __비트마스크란?__

__BitMast__ 는 이진수를 사용하는 컴퓨터 연산 방식을 이용한 것입니다.

__정수의 이진수 표현을 자료구조로 쓰는 기법__ 을 의미합니다.<br><Br>

### __특징__

- 이진수는 0 과 1 로 이루어져 있어 하나의 비트bit 가 표현할 수 있는 경우는 두 가지입니다.

- 보통 어떠한 비트가 1 이면 "true", 0 이면 "false"를 의미합니다.<br><Br>

### __장점__

1. 수행시간이 빠릅니다.

    - 비트마스크 연산은 bit 연산이기 때문에 O(1) 시간 복잡도로 구현되는 경우가 많습니다.

    (주의할 점은, 비트의 개수만큼의 원소를 다룰 수 있기 때문에 연산 횟수가 늘어날수록 차이가 커집니다.)

2. 코드가 짧다.

    - 집합연산자들을 비트연산자로 변환하여 한 줄로 작성할 수 있습니다.

3. 메모리 사용량이 적다.

    - 비트마스크 이용의 __가장 큰 장점__ 입니다.

    - 만약 10개의 비트bit 가 존재한다면,
    각 비트 당 두 가지 경우를 가지기 때문에 2^10 의 경우를 표현할 수 있습니다.

    - 하나의 정수로 매우 많은 경우의 수를 표현할 수 있어 효율적이고,
    더 많은 데이터를 미리 계산해 저장해 둘 수 있습니다.

<br><Br>

## __비트 연산자__

비트마스크에는 비트연산자를 사용합니다.

### __1. AND &__
 : 두 비트 __모두 1인 경우__ 1 입니다.

### __2. OR |__
 :  두 비트 중 __하나라도 1인 경우__ 1 입니다.

### __3. XOR ^__
 : 두 비트가 __서로 다른 경우__ 1 입니다.

### __4. NOT ~__
 : 피연산자의 모든 비트를 __반전__ 시킵니다.

### __5. Shift << >>__
 : 비트를 왼쪽, 오른쪽 원하는 만큼 움직입니다.
<br><Br>

## __비트마스크 이용한 집합 구현__

- __공집합 구하기__

    공집합은 원소가 하나도 없는 빈 상태를 의미합니다.

    즉 bit 가 모두 꺼진 상황,

    따라서 __상수 0__ 이 공집합을 표현합니다.<BR><bR>

- __꽉 찬 집합 구하기__

    반대로 꽉 찬 집합은 bit 가 모두 켜진 상황입니다.

    따라서 1111111111(2) 의 값을 가져야합니다.

    이를 위해서 10000000000(2) 에서 1을 빼주면 01111111111(2) 로 만들 수 있습니다.

    비트 연산자로 표현하면 아래와 같습니다.

    __A =(1 << 10) - 1;__  
    <bR>

- __원소 추가__

    A 집합에서 특정 원소를 추가하려면 해당 원소에 해당하는 bit 만 켜줘야 합니다.

    OR 연산을 이용하면 해당 원소가 꺼져있었어도 킬 수 있습니다.

    이미 A 원소가 켜져있어 포함된 상태라면 변화가 없습니다.

    __A |= (1 << K);__
    <bR><BR>

- __원소 삭제__

    A 집합에서 특정 원소를 삭제하려면 해당 원소에 해당하는 bit 를 꺼줘야합니다.

    AND 연산을 이용해 해당 원소에 해당하는 bit 만을 0으로 연산하면 됩니다.

    우선 ~(1 << K) 을 연산하면 K 번째 해당하는 bit만 0이 됩니다.

    그리고 AND 연산을 하면 해당 원소가 꺼져있었든 켜져있었든 상관없이 0이됩니다.

    __A &= ~(1 << K)__ 
    <BR><bR>

- __원소의 포함 여부 확인__

    AND 연산으로 1과 연산해주면 해당 원소가 1이었을 경우에만 1이 반환되므로

    원래 상태를 알 수 있습니다.

    __if(A &= (1 << K))__
    <Br><bR>


- __원소 토글__

    A 집합에 해당 원소가 빠져있다면 추가, 추가되어있다면 삭제하는 방법입니다.

    XOR 연산을 이용합니다.

    __A ^= (1 << K)__
    <bR><bR>

- __두 집합 연산__

    합집합 : A | B

    교집합: A & B

    차집합: A & (~B)

    하나만 포함된 원소 집합 : A ^ B
<bR><bR>

- __집합의 크기 구하기__

    집합에서 켜져있는 bit 의 수를 구하면 됩니다.

    ```c
    int bitCount(int A)
    {
        // 공집합 검사
        if(A==0)return 0;

        return A%2 + bitCount(A/2);
    }
    ```
    <bR>

- __최소 원소 찾기__

    켜져 있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는 것입니다.

    A에서 가장 오른쪽에 켜져있는 bit의 오른쪽의 모든 bit는 0입니다.

    컴퓨터는 2의 보수를 이용하여 음수를 표현하기 때문에 -A 를 표현하기 위해 ~A+1을 사용합니다.

    ~A 연산을 하면 K번쨰 bit는 0이되고 오른쪽에 모든 bit는 1이됩니다.

    그리고 ~A 에 1을 더해주게 되면 K 번째보다 오른쪽에 있는 bit는 모두 0이 되고 k번쨰 bit는 1이됩니다.

    따라서 A와 -A룰 AND 연산하면 K번째 bit만 켜진 상태가 됩니다.<br><Br>

- __최소 원소 지우기__

    위와 같은 원리로 가장 오른 쪾에 켜져있는 bit를 지우면 됩니다.

    A에서 1을 빼주면 가장 오른쪽 켜져있는 원소는 0이 되고, 그 오른쪽 원소들은 1이됩니다.
    
    A-1과 AND 연산합니다.<BR><bR>
----

[참고 자료](https://rebro.kr/63)
