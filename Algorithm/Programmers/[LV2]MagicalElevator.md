2023.05.14

# __[프로그래머스 LV2] 마법의 엘리베이터__

----

## __문제__

[마법의 엘리베이터](https://school.programmers.co.kr/learn/courses/30/lessons/148653#qna)<br><Br>

## __나의 풀이__(풀이 참조)
```c++
#include <string>
#include <vector>

using namespace std;

int solution(int storey) {
    int answer = 0;
    
    while(storey != 0)
    {
        int n = storey % 10;
        
        if(n >= 6)
        {
            storey += 10 -n;
            answer += 10 -n;
        }
        else if(n == 5 && (storey/10)%10 >= 5)
        {
            storey += 10 - n;
            answer += 10 - n;
        }
        else
        {
            answer += n;
        }
        storey = storey / 10;
    }
    return answer;
}
```

주어진 층에서 0층까지 최소로 필요한 이동 수를 구하는 문제입니다.

주어진 층수인 숫자를 10으로 나누어 나온 나머지로 몇번을 이동하는것이 최소 이동인지 알 수 있습니다.

항상 10으로 나눈 나머지는 1의 자리의 숫자에 해당합니다.

숫자가 6일 경우는 

0에서 6만큼 이동하는 것보다,

10에서 4만큼 빼서 6으로 이동하는 것이 더 적은 이동이 필요합니다.

따라서 첫번쨰 조건인 나머지가 6이상일 경우가 도출됩니다.<br><Br>

그리고 나머지가 4 이하라면 

0에서부터 이동하는것이

10에서부터 이동하는것보다 빠릅니다.<br><Br>

하지만 나머지가 5인 경우에는 

0에서 이동하는것과 10에서 이동하는 경우 이동 수가 같습니다.

이 경우에는 더 앞자리의 수를 보고 판단합니다.

만약 65일 경우 5의 앞자리 수인 6이 5이상입니다.

해당 경우 첫번째 조건으로 실행한다면 주어진 층수에 10-n을 대입한 값을 더해줍니다.

따라서 70이 되고 

다음 반복을 위해 10으로 나눈다면 7번을 더 이동해야할 수도 있습니다.<br><Br>

반면에 두번째 조건으로 실행한 경우 다음 반복을 위해 10으로 나누면 층수는 그대로 6이 되어 6번을 더 이동합니다.<br><Br>
